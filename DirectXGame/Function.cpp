#include "Function.h"

#include <cassert>
#include <cmath>
#include <string>
#include <vector>

// 関数
Vector3 Add(const Vector3& v1, const Vector3& v2) {
	Vector3 c;
	c = {v1.x + v2.x, v1.y + v2.y, v1.z + v2.z};
	return c;
}

Vector3 Subtract(const Vector3& v1, const Vector3& v2) {
	Vector3 c;
	c = {v1.x - v2.x, v1.y - v2.y, v1.z - v2.z};
	return c;
}

float Multiply(const Vector3& v1, const Vector3& v2) {
	float c;
	c = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
	return c;
}

Matrix4x4 Add(const Matrix4x4& m1, const Matrix4x4& m2) {
	Matrix4x4 c;
	c.m[0][0] = m1.m[0][0] + m2.m[0][0];
	c.m[0][1] = m1.m[0][1] + m2.m[0][1];
	c.m[0][2] = m1.m[0][2] + m2.m[0][2];
	c.m[0][3] = m1.m[0][3] + m2.m[0][3];
	c.m[1][0] = m1.m[1][0] + m2.m[1][0];
	c.m[1][1] = m1.m[1][1] + m2.m[1][1];
	c.m[1][2] = m1.m[1][2] + m2.m[1][2];
	c.m[1][3] = m1.m[1][3] + m2.m[1][3];
	c.m[2][0] = m1.m[2][0] + m2.m[2][0];
	c.m[2][1] = m1.m[2][1] + m2.m[2][1];
	c.m[2][2] = m1.m[2][2] + m2.m[2][2];
	c.m[2][3] = m1.m[2][3] + m2.m[2][3];
	c.m[3][0] = m1.m[3][0] + m2.m[3][0];
	c.m[3][1] = m1.m[3][1] + m2.m[3][1];
	c.m[3][2] = m1.m[3][2] + m2.m[3][2];
	c.m[3][3] = m1.m[3][3] + m2.m[3][3];
	return c;
}

Matrix4x4 Subtract(const Matrix4x4& m1, const Matrix4x4& m2) {
	Matrix4x4 c;
	c.m[0][0] = m1.m[0][0] - m2.m[0][0];
	c.m[0][1] = m1.m[0][1] - m2.m[0][1];
	c.m[0][2] = m1.m[0][2] - m2.m[0][2];
	c.m[0][3] = m1.m[0][3] - m2.m[0][3];
	c.m[1][0] = m1.m[1][0] - m2.m[1][0];
	c.m[1][1] = m1.m[1][1] - m2.m[1][1];
	c.m[1][2] = m1.m[1][2] - m2.m[1][2];
	c.m[1][3] = m1.m[1][3] - m2.m[1][3];
	c.m[2][0] = m1.m[2][0] - m2.m[2][0];
	c.m[2][1] = m1.m[2][1] - m2.m[2][1];
	c.m[2][2] = m1.m[2][2] - m2.m[2][2];
	c.m[2][3] = m1.m[2][3] - m2.m[2][3];
	c.m[3][0] = m1.m[3][0] - m2.m[3][0];
	c.m[3][1] = m1.m[3][1] - m2.m[3][1];
	c.m[3][2] = m1.m[3][2] - m2.m[3][2];
	c.m[3][3] = m1.m[3][3] - m2.m[3][3];
	return c;
}

Matrix4x4 Multiply(const Matrix4x4& m1, const Matrix4x4& m2) {
	Matrix4x4 c;
	c.m[0][0] = m1.m[0][0] * m2.m[0][0] + m1.m[0][1] * m2.m[1][0] + m1.m[0][2] * m2.m[2][0] + m1.m[0][3] * m2.m[3][0];
	c.m[0][1] = m1.m[0][0] * m2.m[0][1] + m1.m[0][1] * m2.m[1][1] + m1.m[0][2] * m2.m[2][1] + m1.m[0][3] * m2.m[3][1];
	c.m[0][2] = m1.m[0][0] * m2.m[0][2] + m1.m[0][1] * m2.m[1][2] + m1.m[0][2] * m2.m[2][2] + m1.m[0][3] * m2.m[3][2];
	c.m[0][3] = m1.m[0][0] * m2.m[0][3] + m1.m[0][1] * m2.m[1][3] + m1.m[0][2] * m2.m[2][3] + m1.m[0][3] * m2.m[3][3];
	c.m[1][0] = m1.m[1][0] * m2.m[0][0] + m1.m[1][1] * m2.m[1][0] + m1.m[1][2] * m2.m[2][0] + m1.m[1][3] * m2.m[3][0];
	c.m[1][1] = m1.m[1][0] * m2.m[0][1] + m1.m[1][1] * m2.m[1][1] + m1.m[1][2] * m2.m[2][1] + m1.m[1][3] * m2.m[3][1];
	c.m[1][2] = m1.m[1][0] * m2.m[0][2] + m1.m[1][1] * m2.m[1][2] + m1.m[1][2] * m2.m[2][2] + m1.m[1][3] * m2.m[3][2];
	c.m[1][3] = m1.m[1][0] * m2.m[0][3] + m1.m[1][1] * m2.m[1][3] + m1.m[1][2] * m2.m[2][3] + m1.m[1][3] * m2.m[3][3];
	c.m[2][0] = m1.m[2][0] * m2.m[0][0] + m1.m[2][1] * m2.m[1][0] + m1.m[2][2] * m2.m[2][0] + m1.m[2][3] * m2.m[3][0];
	c.m[2][1] = m1.m[2][0] * m2.m[0][1] + m1.m[2][1] * m2.m[1][1] + m1.m[2][2] * m2.m[2][1] + m1.m[2][3] * m2.m[3][1];
	c.m[2][2] = m1.m[2][0] * m2.m[0][2] + m1.m[2][1] * m2.m[1][2] + m1.m[2][2] * m2.m[2][2] + m1.m[2][3] * m2.m[3][2];
	c.m[2][3] = m1.m[2][0] * m2.m[0][3] + m1.m[2][1] * m2.m[1][3] + m1.m[2][2] * m2.m[2][3] + m1.m[2][3] * m2.m[3][3];
	c.m[3][0] = m1.m[3][0] * m2.m[0][0] + m1.m[3][1] * m2.m[1][0] + m1.m[3][2] * m2.m[2][0] + m1.m[3][3] * m2.m[3][0];
	c.m[3][1] = m1.m[3][0] * m2.m[0][1] + m1.m[3][1] * m2.m[1][1] + m1.m[3][2] * m2.m[2][1] + m1.m[3][3] * m2.m[3][1];
	c.m[3][2] = m1.m[3][0] * m2.m[0][2] + m1.m[3][1] * m2.m[1][2] + m1.m[3][2] * m2.m[2][2] + m1.m[3][3] * m2.m[3][2];
	c.m[3][3] = m1.m[3][0] * m2.m[0][3] + m1.m[3][1] * m2.m[1][3] + m1.m[3][2] * m2.m[2][3] + m1.m[3][3] * m2.m[3][3];
	return c;
}

Matrix4x4 Inverse(const Matrix4x4& m) {
	Matrix4x4 c;
	float A;
	A = m.m[0][0] * m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[0][0] * m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[0][0] * m.m[1][3] * m.m[2][1] * m.m[3][2] - m.m[0][0] * m.m[1][3] * m.m[2][2] * m.m[3][1] -
	    m.m[0][0] * m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[0][0] * m.m[1][1] * m.m[2][3] * m.m[3][2] - m.m[0][1] * m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[1][0] * m.m[2][3] * m.m[3][1] -
	    m.m[0][3] * m.m[1][0] * m.m[2][1] * m.m[3][2] + m.m[0][3] * m.m[1][0] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[1][0] * m.m[2][3] * m.m[3][2] +
	    m.m[0][1] * m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] * m.m[3][2] - m.m[0][3] * m.m[1][2] * m.m[2][0] * m.m[3][1] -
	    m.m[0][2] * m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] * m.m[3][2] - m.m[0][1] * m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[0][2] * m.m[1][3] * m.m[2][1] * m.m[3][0] -
	    m.m[0][3] * m.m[1][1] * m.m[2][2] * m.m[3][0] + m.m[0][3] * m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[0][2] * m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[0][1] * m.m[1][3] * m.m[2][2] * m.m[3][0];

	c.m[0][0] = (1.0f / A) * (m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[1][3] * m.m[2][1] * m.m[3][2] - m.m[1][3] * m.m[2][2] * m.m[3][1] -
	                          m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[1][1] * m.m[2][3] * m.m[3][2]);
	c.m[0][1] = (1.0f / A) * (-m.m[0][1] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[2][1] * m.m[3][2] + m.m[0][3] * m.m[2][2] * m.m[3][1] +
	                          m.m[0][2] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[2][3] * m.m[3][2]);
	c.m[0][2] = (1.0f / A) * (m.m[0][1] * m.m[1][2] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[3][2] - m.m[0][3] * m.m[1][2] * m.m[3][1] -
	                          m.m[0][2] * m.m[1][1] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[3][2]);
	c.m[0][3] = (1.0f / A) * (-m.m[0][1] * m.m[1][2] * m.m[2][3] - m.m[0][2] * m.m[1][3] * m.m[2][1] - m.m[0][3] * m.m[1][1] * m.m[2][2] + m.m[0][3] * m.m[1][2] * m.m[2][1] +
	                          m.m[0][2] * m.m[1][1] * m.m[2][3] + m.m[0][1] * m.m[1][3] * m.m[2][2]);
	c.m[1][0] = (1.0f / A) * (-m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[1][3] * m.m[2][0] * m.m[3][2] + m.m[1][3] * m.m[2][2] * m.m[3][0] +
	                          m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[1][0] * m.m[2][3] * m.m[3][2]);
	c.m[1][1] = (1.0f / A) * (m.m[0][0] * m.m[2][2] * m.m[3][3] + m.m[0][2] * m.m[2][3] * m.m[3][0] + m.m[0][3] * m.m[2][0] * m.m[3][2] - m.m[0][3] * m.m[2][2] * m.m[3][0] -
	                          m.m[0][2] * m.m[2][0] * m.m[3][3] - m.m[0][0] * m.m[2][3] * m.m[3][2]);
	c.m[1][2] = (1.0f / A) * (-m.m[0][0] * m.m[1][2] * m.m[3][3] - m.m[0][2] * m.m[1][3] * m.m[3][0] - m.m[0][3] * m.m[1][0] * m.m[3][2] + m.m[0][3] * m.m[1][2] * m.m[3][0] +
	                          m.m[0][2] * m.m[1][0] * m.m[3][3] + m.m[0][0] * m.m[1][3] * m.m[3][2]);
	c.m[1][3] = (1.0f / A) * (m.m[0][0] * m.m[1][2] * m.m[2][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] + m.m[0][3] * m.m[1][0] * m.m[2][2] - m.m[0][3] * m.m[1][2] * m.m[2][0] -
	                          m.m[0][2] * m.m[1][0] * m.m[2][3] - m.m[0][0] * m.m[1][3] * m.m[2][2]);
	c.m[2][0] = (1.0f / A) * (m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[1][3] * m.m[2][0] * m.m[3][1] - m.m[1][3] * m.m[2][1] * m.m[3][0] -
	                          m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[1][0] * m.m[2][3] * m.m[3][1]);
	c.m[2][1] = (1.0f / A) * (-m.m[0][0] * m.m[2][1] * m.m[3][3] - m.m[0][1] * m.m[2][3] * m.m[3][0] - m.m[0][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[2][1] * m.m[3][0] +
	                          m.m[0][1] * m.m[2][0] * m.m[3][3] + m.m[0][0] * m.m[2][3] * m.m[3][1]);
	c.m[2][2] = (1.0f / A) * (m.m[0][0] * m.m[1][1] * m.m[3][3] + m.m[0][1] * m.m[1][3] * m.m[3][0] + m.m[0][3] * m.m[1][0] * m.m[3][1] - m.m[0][3] * m.m[1][1] * m.m[3][0] -
	                          m.m[0][1] * m.m[1][0] * m.m[3][3] - m.m[0][0] * m.m[1][3] * m.m[3][1]);
	c.m[2][3] = (1.0f / A) * (-m.m[0][0] * m.m[1][1] * m.m[2][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] - m.m[0][3] * m.m[1][0] * m.m[2][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] +
	                          m.m[0][1] * m.m[1][0] * m.m[2][3] + m.m[0][0] * m.m[1][3] * m.m[2][1]);
	c.m[3][0] = (1.0f / A) * (-m.m[1][0] * m.m[2][1] * m.m[3][2] - m.m[1][1] * m.m[2][2] * m.m[3][0] - m.m[1][2] * m.m[2][0] * m.m[3][1] + m.m[1][2] * m.m[2][1] * m.m[3][0] +
	                          m.m[1][1] * m.m[2][0] * m.m[3][2] + m.m[1][0] * m.m[2][2] * m.m[3][1]);
	c.m[3][1] = (1.0f / A) * (m.m[0][0] * m.m[2][1] * m.m[3][2] + m.m[0][1] * m.m[2][2] * m.m[3][0] + m.m[0][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[2][1] * m.m[3][0] -
	                          m.m[0][1] * m.m[2][0] * m.m[3][2] - m.m[0][0] * m.m[2][2] * m.m[3][1]);
	c.m[3][2] = (1.0f / A) * (-m.m[0][0] * m.m[1][1] * m.m[3][2] - m.m[0][1] * m.m[1][2] * m.m[3][0] - m.m[0][2] * m.m[1][0] * m.m[3][1] + m.m[0][2] * m.m[1][1] * m.m[3][0] +
	                          m.m[0][1] * m.m[1][0] * m.m[3][2] + m.m[0][0] * m.m[1][2] * m.m[3][1]);
	c.m[3][3] = (1.0f / A) * (m.m[0][0] * m.m[1][1] * m.m[2][2] + m.m[0][1] * m.m[1][2] * m.m[2][0] + m.m[0][2] * m.m[1][0] * m.m[2][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] -
	                          m.m[0][1] * m.m[1][0] * m.m[2][2] - m.m[0][0] * m.m[1][2] * m.m[2][1]);

	return c;
}

Matrix4x4 Transpose(const Matrix4x4& m) {
	Matrix4x4 c;
	c.m[0][0] = m.m[0][0];
	c.m[0][1] = m.m[1][0];
	c.m[0][2] = m.m[2][0];
	c.m[0][3] = m.m[3][0];
	c.m[1][0] = m.m[0][1];
	c.m[1][1] = m.m[1][1];
	c.m[1][2] = m.m[2][1];
	c.m[1][3] = m.m[3][1];
	c.m[2][0] = m.m[0][2];
	c.m[2][1] = m.m[1][2];
	c.m[2][2] = m.m[2][2];
	c.m[2][3] = m.m[3][2];
	c.m[3][0] = m.m[0][3];
	c.m[3][1] = m.m[1][3];
	c.m[3][2] = m.m[2][3];
	c.m[3][3] = m.m[3][3];
	return c;
}

Matrix4x4 MakeIdentity4x4() {
	Matrix4x4 c;
	c.m[0][0] = 1.0f;
	c.m[0][1] = 0.0f;
	c.m[0][2] = 0.0f;
	c.m[0][3] = 0.0f;
	c.m[1][0] = 0.0f;
	c.m[1][1] = 1.0f;
	c.m[1][2] = 0.0f;
	c.m[1][3] = 0.0f;
	c.m[2][0] = 0.0f;
	c.m[2][1] = 0.0f;
	c.m[2][2] = 1.0f;
	c.m[2][3] = 0.0f;
	c.m[3][0] = 0.0f;
	c.m[3][1] = 0.0f;
	c.m[3][2] = 0.0f;
	c.m[3][3] = 1.0f;
	return c;
}

Matrix4x4 MakeTranslateMatrix(const Vector3& translate) {
	Matrix4x4 c;
	c.m[0][0] = 1;
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = 1;
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = 1;
	c.m[2][3] = 0;
	c.m[3][0] = translate.x;
	c.m[3][1] = translate.y;
	c.m[3][2] = translate.z;
	c.m[3][3] = 1;
	return c;
}

Matrix4x4 MakeScaleMatrix(const Vector3& scale) {
	Matrix4x4 c;
	c.m[0][0] = scale.x;
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = scale.y;
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = scale.z;
	c.m[2][3] = 0;
	c.m[3][0] = 0;
	c.m[3][1] = 0;
	c.m[3][2] = 0;
	c.m[3][3] = 1;
	return c;
}

Matrix4x4 MakeRotateXMatrix(float radian) {
	Matrix4x4 c;
	c.m[0][0] = 1;
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = std::cos(radian);
	c.m[1][2] = std::sin(radian);
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = -std::sin(radian);
	c.m[2][2] = std::cos(radian);
	c.m[2][3] = 0;
	c.m[3][0] = 0;
	c.m[3][1] = 0;
	c.m[3][2] = 0;
	c.m[3][3] = 1;
	return c;
}

Matrix4x4 MakeRotateYMatrix(float radian) {
	Matrix4x4 c;
	c.m[0][0] = std::cos(radian);
	c.m[0][1] = 0;
	c.m[0][2] = -std::sin(radian);
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = 1;
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = std::sin(radian);
	c.m[2][1] = 0;
	c.m[2][2] = std::cos(radian);
	c.m[2][3] = 0;
	c.m[3][0] = 0;
	c.m[3][1] = 0;
	c.m[3][2] = 0;
	c.m[3][3] = 1;
	return c;
}

Matrix4x4 MakeRotateZMatrix(float radian) {
	Matrix4x4 c;
	c.m[0][0] = std::cos(radian);
	c.m[0][1] = std::sin(radian);
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = -std::sin(radian);
	c.m[1][1] = std::cos(radian);
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = 1;
	c.m[2][3] = 0;
	c.m[3][0] = 0;
	c.m[3][1] = 0;
	c.m[3][2] = 0;
	c.m[3][3] = 1;
	return c;
}

Matrix4x4 MakeRotateMatrix(const Vector3& rotate) {
	Matrix4x4 rotateMatrix;
	rotateMatrix = Multiply(MakeRotateXMatrix(rotate.x), Multiply(MakeRotateYMatrix(rotate.y), MakeRotateZMatrix(rotate.z)));
	return rotateMatrix;
}

Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
	Matrix4x4 c;
	// 回転行列統合
	Matrix4x4 rx = MakeRotateXMatrix(rotate.x);
	Matrix4x4 ry = MakeRotateYMatrix(rotate.y);
	Matrix4x4 rz = MakeRotateZMatrix(rotate.z);
	Matrix4x4 rxyz = Multiply(rx, Multiply(ry, rz));

	c.m[0][0] = scale.x * rxyz.m[0][0];
	c.m[0][1] = scale.x * rxyz.m[0][1];
	c.m[0][2] = scale.x * rxyz.m[0][2];
	c.m[0][3] = 0;
	c.m[1][0] = scale.y * rxyz.m[1][0];
	c.m[1][1] = scale.y * rxyz.m[1][1];
	c.m[1][2] = scale.y * rxyz.m[1][2];
	c.m[1][3] = 0;
	c.m[2][0] = scale.z * rxyz.m[2][0];
	c.m[2][1] = scale.z * rxyz.m[2][1];
	c.m[2][2] = scale.z * rxyz.m[2][2];
	c.m[2][3] = 0;
	c.m[3][0] = translate.x;
	c.m[3][1] = translate.y;
	c.m[3][2] = translate.z;
	c.m[3][3] = 1;

	return c;
}

float Cot(float rad) {
	float c;

	c = 1 / std::tan(rad);

	return c;
}

Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip) {
	Matrix4x4 c;
	c.m[0][0] = (1 / aspectRatio) * Cot(fovY / 2);
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = Cot(fovY / 2);
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = farClip / (farClip - nearClip);
	c.m[2][3] = 1;
	c.m[3][0] = 0;
	c.m[3][1] = 0;
	c.m[3][2] = (-nearClip * farClip) / (farClip - nearClip);
	c.m[3][3] = 0;
	return c;
}

Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip) {
	Matrix4x4 c;
	c.m[0][0] = 2 / (right - left);
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = 2 / (top - bottom);
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = 1 / (farClip - nearClip);
	c.m[2][3] = 0;
	c.m[3][0] = (left + right) / (left - right);
	c.m[3][1] = (top + bottom) / (bottom - top);
	c.m[3][2] = nearClip / (nearClip - farClip);
	c.m[3][3] = 1;
	return c;
}

Matrix4x4 makeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth) {
	Matrix4x4 c;
	c.m[0][0] = width / 2;
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = -height / 2;
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = maxDepth - minDepth;
	c.m[2][3] = 0;
	c.m[3][0] = left + (width / 2);
	c.m[3][1] = top + (height / 2);
	c.m[3][2] = minDepth;
	c.m[3][3] = 1;
	return c;
}

Vector3 Cross(const Vector3& a, const Vector3& b) {
	Vector3 c;

	c.x = (a.y * b.z) - (a.z * b.y);
	c.y = (a.z * b.x) - (a.x * b.z);
	c.z = (a.x * b.y) - (a.y * b.x);

	return c;
}

float Cross(const Vector2& a, const Vector2& b) {
	float result;
	result = a.x * b.y - a.y * b.x;
	return result;
}

float Length(const Vector3& v) {
	float c;
	c = sqrtf(powf(v.x, 2) + powf(v.y, 2) + powf(v.z, 2));
	return c;
}

float Length(const Vector2& v) {
	float c;
	c = sqrtf(powf(v.x, 2) + powf(v.y, 2));
	return c;
}

Vector3 Normalize(const Vector3& v) {
	Vector3 c;
	// 長さを求める
	float length = Length(v);
	// length=0で無ければ正規化
	if (length != 0) {
		c.x = v.x / length;
		c.y = v.y / length;
		c.z = v.z / length;
	} else {
		assert("正規化できません");
	}
	return c;
}

Vector2 Normalize(const Vector2& v) {
	Vector2 c = {0.0f, 0.0f};
	// 長さを求める
	float length = Length(v);
	// length=0で無ければ正規化
	if (length != 0) {
		c.x = v.x / length;
		c.y = v.y / length;
	} else {
		assert("正規化できません");
	}
	return c;
}

Vector3 Transform(const Vector3& vector, const Matrix4x4& matrix) {
	Vector3 result;
	result.x = vector.x * matrix.m[0][0] + vector.y * matrix.m[1][0] + vector.z * matrix.m[2][0] + 1.0f * matrix.m[3][0];
	result.y = vector.x * matrix.m[0][1] + vector.y * matrix.m[1][1] + vector.z * matrix.m[2][1] + 1.0f * matrix.m[3][1];
	result.z = vector.x * matrix.m[0][2] + vector.y * matrix.m[1][2] + vector.z * matrix.m[2][2] + 1.0f * matrix.m[3][2];
	float w = vector.x * matrix.m[0][3] + vector.y * matrix.m[1][3] + vector.z * matrix.m[2][3] + 1.0f * matrix.m[3][3];
	assert(w != 0.0f);
	result.x /= w;
	result.y /= w;
	result.z /= w;
	return result;
}

Vector3 TransformNormal(const Vector3& v, const Matrix4x4& m) {
	Vector3 result{v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0], v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1], v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2]};
	return result;
}

float Dot(const Vector3& v1, const Vector3& v2) {
	float c;
	c = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
	return c;
}

float Dot(const Vector2& v1, const Vector2& v2) {
	float c;
	c = v1.x * v2.x + v1.y * v2.y;
	return c;
}

float AngleOf2VectorX(const Vector3& v1, const Vector3& v2) {
	// X軸回転のため、引数のベクトルをzy成分に分解(長さの計算する手間省くため正規化)
	Vector2 longHand = Normalize(Vector2(v1.z, v1.y));
	Vector2 hourHand = Normalize(Vector2(v2.z, v2.y));
	// 内積とベクトル長さを使ってcosθを求める
	float cos_theta = Dot(longHand, hourHand);
	// cosθからθを求める
	float theta = std::acos(cos_theta);
	// 2ベクトルの外積を求め、hourHandが左にあるならマイナス
	if (Cross(longHand, hourHand) > 0.0f) {
		theta = -theta;
	}
	// cosθの値で場合分け(NAN回避処理)
	if (cos_theta >= 1.0f) {
		theta = 0.0f;
	} else if (cos_theta <= -1.0f) {
		theta = pi;
	}
	return theta;
}

float AngleOf2VectorY(const Vector3& v1, const Vector3& v2) {
	// Y軸回転のため、引数のベクトルをxz成分に分解(長さの計算する手間省くため正規化)
	Vector2 longHand = Normalize(Vector2(v1.x, v1.z));
	Vector2 hourHand = Normalize(Vector2(v2.x, v2.z));
	// 内積とベクトル長さを使ってcosθを求める
	float cos_theta = Dot(longHand, hourHand);
	// cosθからθを求める
	float theta = std::acos(cos_theta);
	// 2ベクトルの外積を求め、hourHandが左にあるならマイナス
	if (Cross(longHand, hourHand) > 0.0f) {
		theta = -theta;
	}
	// cosθの値で場合分け(NAN回避処理)
	if (cos_theta >= 1.0f) {
		theta = 0.0f;
	} else if (cos_theta <= -1.0f) {
		theta = pi;
	}
	return theta;
}

float AngleOf2VectorZ(const Vector3& v1, const Vector3& v2) {
	// Z軸回転のため、引数のベクトルをxy成分に分解(長さの計算する手間省くため正規化)
	Vector2 longHand = Normalize(Vector2(v1.x, v1.y));
	Vector2 hourHand = Normalize(Vector2(v2.x, v2.y));
	// 内積とベクトル長さを使ってcosθを求める
	float cos_theta = Dot(longHand, hourHand);
	// cosθからθを求める
	float theta = std::acos(cos_theta);
	// 2ベクトルの外積を求め、hourHandが左にあるならマイナス
	if (Cross(longHand, hourHand) > 0.0f) {
		theta = -theta;
	}
	// cosθの値で場合分け(NAN回避処理)
	if (cos_theta >= 1.0f) {
		theta = 0.0f;
	} else if (cos_theta <= -1.0f) {
		theta = pi;
	}
	return theta;
}

float AngleOf2Vector(const Vector2& v1, const Vector2& v2) {
	// 引数のベクトルをxy成分に分解(長さの計算する手間省くため正規化)
	Vector2 longHand = Normalize(v1);
	Vector2 hourHand = Normalize(v2);
	// 内積とベクトル長さを使ってcosθを求める
	float cos_theta = Dot(longHand, hourHand);
	// cosθからθを求める
	float theta = std::acos(cos_theta);
	// 2ベクトルの外積を求め、hourHandが左にあるならマイナス
	if (Cross(longHand, hourHand) > 0.0f) {
		theta = -theta;
	}
	// cosθの値で場合分け(NAN回避処理)
	if (cos_theta >= 1.0f) {
		theta = 0.0f;
	} else if (cos_theta <= -1.0f) {
		theta = pi;
	}
	return theta;
}

Vector3 Multiply(const float& s, const Vector3& v) {
	Vector3 c;
	c.x = s * v.x;
	c.y = s * v.y;
	c.z = s * v.z;
	return c;
}

Matrix4x4 MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth) {
	Matrix4x4 c;
	c.m[0][0] = width / 2;
	c.m[0][1] = 0;
	c.m[0][2] = 0;
	c.m[0][3] = 0;
	c.m[1][0] = 0;
	c.m[1][1] = -height / 2;
	c.m[1][2] = 0;
	c.m[1][3] = 0;
	c.m[2][0] = 0;
	c.m[2][1] = 0;
	c.m[2][2] = maxDepth - minDepth;
	c.m[2][3] = 0;
	c.m[3][0] = left + (width / 2);
	c.m[3][1] = top + (height / 2);
	c.m[3][2] = minDepth;
	c.m[3][3] = 1;
	return c;
}

Vector3 Lerp(const Vector3& v1, const Vector3& v2, float t) {
	Vector3 p;
	p = Add(v1, Multiply(t, Subtract(v2, v1)));
	return p;
}

float Lerp(const float& l1, const float& l2, float t) {
	float p;
	p = (1 - t) * l1 + t * l2;
	return p;
}

float LerpShortAngle(float sRadian, float eRadian, float t) {
	// 角度の差分を求める
	float diff = eRadian - sRadian;
	// 角度を{-2PI,+2PI}に補正する
	diff = std::fmodf(diff, 2 * pi);

	// 角度を{-PI,+PI}に補正する
	if (diff > pi) {
		diff -= 2 * pi;
	} else if (diff < -pi) {
		diff += 2 * pi;
	}

	return Lerp(sRadian, sRadian + (diff * t), t);
}

Vector3 Slerp(const Vector3& v1, const Vector3& v2, float t) {
	// 各ベクトルを正規化
	Vector3 v1n, v2n;
	v1n = Normalize(v1);
	v2n = Normalize(v2);
	// 内積を求める→cosθ
	float dot = Dot(v1n, v2n);
	// sinθを求める
	if (dot > 1.0f) {
		dot = 1.0f;
	}
	// アークコサインでθの角度を求める
	float theta = std::acos(dot);
	// シータの角度からsinθを求める
	float sinTheta = std::sin(theta);
	// サイン(θ(1-t))を求める
	float sinThetaFrom = std::sin((1 - t) * theta);
	// sinθtを求める
	float sinThetaTo = std::sin(t * theta);
	// 球面線形補完したベクトル(単位ベクトル)
	Vector3 nvec = Add(Multiply(sinThetaFrom / sinTheta, v1n), Multiply(sinThetaTo / sinTheta, v2n));
	// ゼロ除算を防ぐ
	if (sinTheta < 1.0e-5) {
		nvec = v1n;
	} else {
		// 球面線形補完したベクトル
		nvec = Multiply(1 / sinTheta, nvec);
	}
	// ベクトルの長さはv1とv2の長さを線形補完
	float length1 = Length(v1);
	float length2 = Length(v2);
	// Lerpで補完ベクトルの長さを求める
	float length = Lerp(length1, length2, t);

	// 長さを反映
	return Multiply(length, nvec);
}